global:
  # -- String to partially override appserver-microservices.fullname template with a string (will prepend the release name)
  nameOverride: ""
  # -- String to fully override appserver-microservices.fullname template with a string
  fullnameOverride: ""
  # -- Number of appserver microservices replicas to deploy
  replicaCount: 1
  # -- Standard JAVA_OPTS that should be passed to this service
  javaOpts: "-XX:GCTimeRatio=19 -XX:MinHeapFreeRatio=20 -XX:MaxHeapFreeRatio=30 --add-opens java.base/java.io=ALL-UNNAMED --add-opens java.management/javax.management.openmbean=ALL-UNNAMED --add-opens java.base/java.lang.reflect=ALL-UNNAMED --add-opens java.management/javax.management=ALL-UNNAMED -Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager"
  # -- Optionally specify an array of imagePullSecrets.
  # Secrets must be manually created in the namespace.
  # e.g:
  # pullSecrets:
  #   - myRegistryKeySecretName
  #
  imagePullSecrets: []

  # -- Node labels for pod assignment
  nodeSelector: { }
  # -- Toleration labels for pod assignment
  tolerations: [ ]
  # -- Affinity labels for pod assignment
  affinity: { }

services:
  gateway-service:
    enabled: true
    # -- Number of appserver microservices replicas to deploy
    replicaCount: 1
    image:
      # -- Image repository
      repository: ghcr.io/radar-base/radar-appserver/gateway-service
      # -- Image tag (immutable tags are recommended)
      tag:
      # -- Image pull policy
      pullPolicy: IfNotPresent
    # -- Configure radar-appserver pods' Security Context
    podSecurityContext: {}
    # fsGroup: 2000

    # -- Configure radar-appserver containers' Security Context
    securityContext: {}
      # capabilities:
      #   drop:
      #   - ALL
      # readOnlyRootFilesystem: true
      # runAsNonRoot: true
      # runAsUser: 1000
    service:
      # -- Kubernetes Service type
      type: ClusterIP
      # -- appserver-microservices service port
      port: 8080
    ports:
      # -- appserver-microservices container port
      containerPort: 8080
    # -- Command to run when starting the container.
    command: "gateway-service"
    # -- Reconfigure Ingress to not force TLS
    disable_tls: false
    # -- The protocol in advertised URIs (https, http)
    advertised_protocol: https
    ingress:
      # -- Enable ingress controller resource
      enabled: true
      # -- Annotations that define default ingress class, certificate issuer and session configuration
      # @default -- check values.yaml
      annotations:
        cert-manager.io/cluster-issuer: letsencrypt-prod
        nginx.ingress.kubernetes.io/rewrite-target: /$1
      # -- Path within the url structure
      path: "/appserver/?(.*)"
      # -- Ingress path type
      pathType: ImplementationSpecific
      # -- IngressClass that will be be used to implement the Ingress (Kubernetes 1.18+)
      ingressClassName: nginx
      # -- Hosts to accept requests from
      hosts:
        - localhost
      tls:
        # -- TLS Secret Name
        secretName: radar-base-tls
    resources:
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #   cpu: 100m
      #   memory: 128Mi

      # -- CPU/Memory resource requests
      requests:
        cpu: 100m
        memory: 128Mi

    # -- Node labels for pod assignment
    nodeSelector: {}

    # -- Toleration labels for pod assignment
    tolerations: []

    # -- Affinity labels for pod assignment
    affinity: {}

    # -- Extra environment variables
    extraEnvVars: []
    #  - name: BEARER_AUTH
    #    value: true

    # Should the JAVA_OPTS be added as environment variable for the service
    injectJavaOpts: true
    # -- Custom livenessProbe that overrides the default one
    customLivenessProbe: {}

    livenessProbe:
      # -- Enable livenessProbe
      enabled: true
      # -- Initial delay seconds for livenessProbe
      initialDelaySeconds: 5
      # -- Period seconds for livenessProbe
      periodSeconds: 30
      # -- Timeout seconds for livenessProbe
      timeoutSeconds: 5
      # -- Success threshold for livenessProbe
      successThreshold: 1
      # -- Failure threshold for livenessProbe
      failureThreshold: 3

    # -- Custom readinessProbe that overrides the default one
    customReadinessProbe: {}

    readinessProbe:
      # -- Enable readinessProbe
      enabled: true
      # -- Initial delay seconds for readinessProbe
      initialDelaySeconds: 5
      # -- Period seconds for readinessProbe
      periodSeconds: 30
      # -- Timeout seconds for readinessProbe
      timeoutSeconds: 5
      # -- Success threshold for readinessProbe
      successThreshold: 1
      # -- Failure threshold for readinessProbe
      failureThreshold: 3

    # -- Custom startupProbe that overrides the default one
    customStartupProbe: {}

    startupProbe:
      # -- Enable startupProbe
      enabled: true
      # -- Initial delay seconds for startupProbe
      initialDelaySeconds: 5
      # -- Period seconds for startupProbe
      periodSeconds: 10
      # -- Timeout seconds for startupProbe
      timeoutSeconds: 10
      # -- Success threshold for startupProbe
      successThreshold: 1
      # -- Failure threshold for startupProbe
      failureThreshold: 30
    # -- URL of the Management Portal
    managementportal_url: http://management-portal:8080/managementportal

    # -- Contents of a gateway-service.yml configuration file
    # @default -- check `values.yaml`
    config:
      enabled: true
      mouthPath: "/etc/radar-appserver/gateway-service.yml"
      values:
        resourceConfig: org.radarbase.appserver.microservices.gateway.enhancer.factory.GatewayServiceResourceEnhancerFactory
        auth:
          managementPortalUrl: http://management-portal:8081/managementportal
          resourceName: res_AppServer
        routes:
          - name: project
            path: projects
            baseUrl: http://radar-appserver-project-service:9010/
          - name: user
            path:
            baseUrl: http://radar-appserver-user-service:9013/
          - name: github
            path: github/content
            baseUrl: http://radar-appserver-github-service:9011/
          - name: protocol
            path:
            baseUrl: http://radar-appserver-protocol-service:9012/
          - name: task
            path:
            baseUrl: http://radar-appserver-task-service:9014/
          - name: messaging
            path:
            baseUrl: http://radar-appserver-messaging-service:9015/
        server:
          # Base URI of the application.
          baseUri: http://localhost:8080
          # Timeout for requests to the application.
          requestTimeout: 30
          isJmxEnabled: false

    # envMap = map of ENV_NAME -> { value: "..." }  OR -> { valueFrom: { secretKeyRef: {...} } }
    # @ignore
    envMap:
      APPSERVER_PROJECT_SERVICE_BASE_URL:
        value: "http://radar-appserver-project-service:9010/"
      APPSERVER_USER_SERVICE_BASE_URL:
        value: "http://radar-appserver-user-service:9013/"
      APPSERVER_GITHUB_SERVICE_BASE_URL:
        value: "http://radar-appserver-github-service:9011/"
      APPSERVER_PROTOCOL_SERVICE_BASE_URL:
        value: "http://radar-appserver-protocol-service:9012/"
      APPSERVER_TASK_SERVICE_BASE_URL:
        value: "http://radar-appserver-task-service:9014/"
      APPSERVER_CLOUD_SERVICE_BASE_URL:
        value: "http://radar-appserver-cloud-messaging-service:9015/"
      APPSERVER_MANAGEMENTPORTAL_BASE_URL:
        value: "http://management-portal:8080/managementportal"

    # @ignore
    volumes:
      - name: config
        configMap:
          nameTemplate: serviceFullname
    # @ignore
    volumeMounts:
      - name: config
        mountPath: /etc/radar-appserver/

    # -- Network policy defines who can access this application and who this applications has access to
    # @default -- check `values.yaml`
    networkpolicy:
      policyTypes:
        - Ingress
        - Egress
      ingress:
        - from:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: '{{ .Release.Namespace }}'
              podSelector:
                matchLabels:
                  app.kubernetes.io/name: ingress-nginx
      egress:
        - to:
            - ipBlock:
                cidr: 0.0.0.0/0
                except:
                  - 10.0.0.0/8
                  - 192.168.0.0/16
                  - 172.16.0.0/12
        - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: '{{ .Release.Namespace }}'
              podSelector:
                matchLabels:
                  app.kubernetes.io/name: 'management-portal'
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: '{{ .Release.Namespace }}'
              podSelector:
                matchLabels:
                  app.kubernetes.io/name: '{{ .Values.postgres.host | default "radar-cloudnative-postgresql-cluster" | trunc 63 | trimSuffix "-" }}'
        - to:
            - namespaceSelector:
                matchLabels:
                  kubernetes.io/metadata.name: kube-system
              podSelector:
                matchLabels:
                  k8s-app: kube-dns
          ports:
            - port: 53
              protocol: UDP
            - port: 53
              protocol: TCP















#
#
## -- Google credentials containing FCM server key, etc.
#google_application_credentials: ""
## With helmfile, this can be set in a production.yaml.gotmpl
## file by setting
##   google_application_credentials: {{ readFile "etc/radar-appserver/google-credentials.json" | quote }}
#
## -- Github client token which is used for authenticating requests
#github_client_token: ""
#
#protocol:
#  githubProtocolRepo: RADAR-base/RADAR-aRMT-protocols
#  protocolFileName: protocol.json
#  githubBranch: master
#
#smtp:
#  # -- set to true, if sending of notifications via email should be enabled.
#  enabled: false
#  # -- Hostname of the SMTP server
#  host: smtp
#  # -- Port of the SMTP server
#  port: 25
#  # -- Username of the SMTP server
#  username: username
#  # -- Password of the SMTP server
#  password: secret
#  # -- Email address which should be used to send activation emails
#  from: noreply@example.com
#  # -- set to true,if TTLS should be enabled
#  starttls: false
#  # -- set to true, if the account should be authenticated before sending emails
#  auth: true
#  # -- Timeout (ms) for establishing TCP connection to server
#  connect_timeout: 10000
#  # -- Timeout (ms) for read operations (socket read timeout), waiting for server responses
#  read_timeout: 10000
#
#    - name: APPSERVER_JDBC_URL
#      valueFrom:
#        secretKeyRef:
#          name: {{ .Values.postgres.urlSecret.name | default $secretName }}
#          key: {{ .Values.postgres.urlSecret.key | default "databaseUrl" }}
#    - name: APPSERVER_JDBC_USERNAME
#      valueFrom:
#        secretKeyRef:
#          name: {{ .Values.postgres.userSecret.name | default $secretName }}
#          key: {{ .Values.postgres.userSecret.key | default "databaseUser" }}
#    - name: APPSERVER_JDBC_PASSWORD
#      valueFrom:
#        secretKeyRef:
#          name: {{ .Values.postgres.passwordSecret.name | default $secretName }}
#          key: {{ .Values.postgres.passwordSecret.key | default "databasePassword" }}
#    - name: APPSERVER_HIBERNATE_DIALECT
#      value: {{ .Values.postgres.hibernateDialect }}
#    - name: APPSERVER_JDBC_DRIVER
#      value: {{ .Values.postgres.jdbcDriver }}
    # Configuration of the Postgres data base to store data from Appserver
    postgres:
      # -- host name of the postgres db
      host:
      # -- port of the postgres db
      port:
      # -- database name
      database:
      # -- Kubernetes secret containing the database JDBC Connection url
      # (disables use of 'host', 'port' and 'database' values).
      urlSecret:
        name: radar-cloudnative-postgresql-appserver
        key: jdbc-uri
      # -- postgres user
      user:
      # -- Kubernetes secret containing the database user
      # (disables use of 'user' value).
      userSecret:
        name: radar-cloudnative-postgresql-appserver
        key: username
      # -- password of the postgres user
      password:
      # -- Kubernetes secret containing the database password
      # (disables use of 'password' value).
      passwordSecret:
        name: radar-cloudnative-postgresql-appserver
        key: password

      hibernateDialect: org.hibernate.dialect.PostgreSQLDialect
      jdbcDriver: org.postgresql.Driver

      # -- Additional JDBC connection parameters e.g. sslmode=verify-full.
      # Ignored when using 'urlSecret'.
      connection_parameters: ""
      ssl:
        # -- set to true of the connecting to postgres using SSL
        enabled: false
        keystorepassword: keystorepassword
